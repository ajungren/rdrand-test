use std::process::exit;
use std::str::FromStr;
use std::string::ToString;

use clap::clap_app;

mod error;
mod generator;
mod rdrand;

pub use crate::error::Error;
pub use crate::generator::{Generator, GeneratorOptions};
pub use crate::rdrand::RdRand;

const SMOKE_TEST_ITERATIONS: &str = "4";

fn validate<T: FromStr>(value: String) -> Result<(), String>
where
    T::Err: ToString,
{
    match T::from_str(&value) {
        Ok(_) => Ok(()),
        Err(err) => Err(err.to_string()),
    }
}

fn run() -> Result<(), Error> {
    let matches = clap_app!(("rdrand-test") =>
        (version: env!("CARGO_PKG_VERSION"))
        (about: env!("CARGO_PKG_DESCRIPTION"))
        (@arg quiet: -q --quiet "Disables output of all generated values\n(Only outputs how many duplicate values were generated)")
        (@arg smoke_test: -s --("smoke-test") "Runs a much shorter test, implies --quiet\n(Only verifies that the same number is not generated by consecutive RDRAND executions)")
        (@arg ITERATIONS: default_value("512") default_value_if("smoke_test", None, SMOKE_TEST_ITERATIONS) {validate::<usize>} "Number of iterations to run for each integer size")
    ).get_matches();

    // `iterations` has already been validated by clap
    let iterations = matches.value_of("ITERATIONS").unwrap();
    let iterations = usize::from_str(iterations).unwrap();
    let options = if matches.is_present("quiet") {
        GeneratorOptions::QUIET
    } else if matches.is_present("smoke_test") {
        GeneratorOptions::SMOKE_TEST
    } else {
        GeneratorOptions::default()
    };
    let generator = Generator::new(iterations, options)?;

    let mut succeeded = true;
    print!("Running {} iterations\n\n", iterations);
    succeeded &= generator.run::<u16>();
    println!();
    succeeded &= generator.run::<u32>();
    println!();
    succeeded &= generator.run::<u64>();

    // `Generator::generate` does not output a trailing EOL after running.
    if generator.is_smoke_test() {
        println!();
    }

    // `255` is returned to distinguish RDRAND issues from `clap` errors.
    if !succeeded {
        exit(255);
    }

    Ok(())
}

fn main() {
    if let Err(err) = run() {
        eprintln!("error: {}", err);
        exit(1);
    }
}
